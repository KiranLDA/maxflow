hello()
library(maxflow)
hello()
data <- data.frame(site= A:D, Lat= 1:4, Lon= 5:8, Pop=100:104)
seq(A,D)
data <- data.frame(site= letters(1:4), Lat= 1:4, Lon= 5:8, Pop=100:104)
letters(1,4)
letters[1:4]
data <- data.frame(site= LETTERS[1:4], Lat= 1:4, Lon= 5:8, Pop=100:104)
1:4
5:8
100:104
data <- data.frame(site= LETTERS[1:4], Lat= 1:4, Lon= 5:8, Pop=100:103)
data
# Project latitude and longitude
SpatialPoints(coords=data[,3:2], proj4string=CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs "))
require(sp)
# Project latitude and longitude
SpatialPoints(coords=data[,3:2], proj4string=CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs "))
# Project latitude and longitude
pts  = SpatialPoints(coords=data[,3:2], proj4string=CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs "))
dist = rdist.earth(pts@coords)
pts@coords
require (fields)
dist = rdist.earth(pts@coords)
dist
# Project latitude and longitude
pts  = SpatialPoints(coords = cbind(data$Lat, data$Lon), proj4string=CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs "))
dist = rdist.earth(pts@coords)
colnames(dist)=rownames(dist)=data$site
dist
data
print("make sure data is formatted as a dataframe as folows: \n
site  Lat Lon Pop\n
A 1 5 100\n
B 2 6 101")
print("make sure data is formatted as a dataframe as folows: /n
site  Lat Lon Pop/n
A 1 5 100/n
B 2 6 101")
print("make sure data is formatted as a dataframe as folows:
site  Lat Lon Pop
A 1 5 100
B 2 6 101")
library(maxflow)
data <- data.frame(site= LETTERS[1:4], Lat= 1:4, Lon= 5:8, Pop=100:103)
Point_2_Distance_Network(data)
data <- data.frame(Site= LETTERS[1:4], Lat= 1:4, Lon= 5:8, Pop=100:103)
Point_2_Distance_Network(data)
net <- Point_2_Distance_Network(data)
Point_2_Distance_Network(data)
dist
rm(list=ls())
library(maxflow)
data <- data.frame(Site= LETTERS[1:4], Lat= 1:4, Lon= 5:8, Pop=100:103)
net <- Point_2_Distance_Network(data)
dist
library(prioritizr)
install.packages("roxygen2")
library(roxygen2)
library(maxflow)
?maxflow::Point_2_Distance_Network
library(maxflow)
?Point_2_Distance_Network
dta <- data.frame(Site= LETTERS[1:4], Lat= 1:4, Lon= 5:8, Pop=100:103)
net <- Point_2_Distance_Network(dta)
net
Point_2_Distance_Network(dta)
library(maxflow)
?Point_2_Distance_Network
library(maxflow)
library(maxflow)
library(maxflow)
library(maxflow)
dta <- data.frame(Site= LETTERS[1:4], Lat= 1:4, Lon= 5:8, Pop=100:103)
dist <- Point_2_Distance_Network(dta)
dist
dist = rbind(matrix(0,1,dim(dist)[2]),
dist,
matrix(0,1,dim(dist)[2]))
dist
dist = cbind(matrix(0,dim(dist)[1],1),
dist,
matrix(0,dim(dist)[1],1))
dist
colnames(dist)[1]="source"
rownames(dist)[1]="source"
dist
colnames(dist)[1] = rownames(dist)[1] = "source"
colnames(dist)[length(dist[1,])] = rownames(dist)[length(dist[1,])] = "sink"
dist
library(maxflow)
?Add_Source_Sink
library(maxflow)
?Add_Source_Sink
library(maxflow)
?Add_Source_Sink
dta <- data.frame(Site= LETTERS[1:4], Lat= 1:4, Lon= 5:8, Pop=100:103)
dist <- Point_2_Distance_Network(dta)
Add_Source_Sink(dist)
library(maxflow)
dta <- data.frame(Site= LETTERS[1:4], Lat= 1:4, Lon= 5:8, Pop=100:103)
dist <- Point_2_Distance_Network(dta)
Add_Source_Sink(dist)
dta
lower.tri(dist, diag = FALSE)
dist[lower.tri(dist, diag = FALSE)] <- 0
dist
library(maxflow)
?Make_directed_network
dta <- data.frame(Site= LETTERS[1:4], Lat= 1:4, Lon= 5:8, Pop=100:103)
dist <- Point_2_Distance_Network(dta)
Make_directed_network(dist)
?rnorm
tracks <- rnorm(10, mean= 500,sd =1000)
tracks
rpois(10, mean= 500,sd =1000)
?rpois
rpois(10, 500)
tracks <- rnorm(10, 500, 200)
tracks
approxfun(density(tracks,adjust=2))
tracks <- rnorm(10, 500, 200)
prob=approxfun(density(tracks,adjust=2))
dist_prob = apply(dist,c(1,2),function(prob) prob(dist))
dist_prob
dist
prob(dist)
dist
apply(dist,c(1,2),function(x) prob(x))
prob=approxfun(density(tracks,adjust=adjust))
dist_prob = apply(dist,c(1,2),function(x) prob(x))
return(dist_prob)
adjust = 2
prob=approxfun(density(tracks,adjust=adjust))
dist_prob = apply(dist,c(1,2),function(x) prob(x))
return(dist_prob)
density(tracks,adjust=adjust)
hist(density(tracks,adjust=adjust))
if (plot) hist(tracks,adjust=adjust, density=TRUE)
hist(tracks,adjust=adjust, density=TRUE)
hist(tracks,adjust=adjust, freq=TRUE)
hist(tracks,adjust=adjust, probability = =TRUE)
hist(tracks,adjust=adjust, probability = TRUE)
hist(tracks,probability = TRUE)
plot(prob)
prob=approxfun(density(tracks,adjust=adjust))
plot(prob)
plot(density(tracks,adjust=adjust))
?density
plot(density(tracks,adjust=5))
plot(density(tracks,adjust=1))
?density
?stats
library(maxflow)
library(maxflow)
486.05 +(243.02 *2)
library(roxygen2)
install.package("packrat")
install.packages("packrat")
# load library
library(maxflow)
# Simulate 10 fake tracks with a mean distance of 500km
tracks <- rnorm(10, 500, 200)
# Create a fake list of sites where animals were seen at, with latitude, longitude and number of anumals seen there
dta <- data.frame(Site= LETTERS[1:4], Lat= 1:4, Lon= 5:8, Pop=100:103)
# create a distance matrix based on these data
dist <- Point_2_Distance_Network(dta)
# calculate the probability of going between these sites given the distance the animal can travel
Dist_P <- Distance_Probability(tracks, dist, adjust=2, plot=TRUE)
# Calculate proportion going into a node
Pop_P <- Population_Proportion(dta, 300)
# make birds/animals prefer sites which a larger proportion of the population has been seen and where the distance is better
network <- Dist_P * Pop_P
# Make the network directed
network <- Make_Directed_Network(network, include_diagonal = TRUE)
#Add supersource and sink nodes
network <- Add_Source_Sink(network)
library(igraph)
install.packages("igraph")
library(igraph)
max_flow
S=matrix(999,7,7)
S[1,2]=1
S[1,3]=2
S[2,5]=2
S[3,4]=1
S[4,5]=1
S[4,6]=3
S[5,6]=2
### List of input parameters for function
n=length(S[,1]) #number of nodes
v=1 #source node
cost=S #distance matrix
### Dijkstra's algorithm
dijkstra=function(n,v,cost,dest){
#create empty variables to store data
dest = numeric(n)
flag = numeric(n)
prev = numeric(n)
# for every node in the network
for(i in 1:n){
prev[i] = -1
dest[i] = cost[v,i] #= distance from start node v to every other node i in the network
}
#initialise counter which keeps track of number of steps through network
count=2
# until we have reached our destination node n
while(count <= n){
min=999
# loop over each node
for(w in 1:n){
#if the new path is less long than the existing smallest one and flag[w] is equal to zero (aka we've not already incuded that node in route)
if(dest[w] < min && !flag[w]){
# overwrite the minimum with the new shortest path and update counter
min=dest[w]
u=w
}
}
flag[u] = 1 #indicate that we go to this site
count = count+1
# loop over each node again keeping in mind where we have already been
for(w in 1:n){
#if the new route is shorter than the previous route
if((dest[u]+cost[u,w] < dest[w]) && !flag[w]){
dest[w]=dest[u]+cost[u,w] #update the distance to destination
prev[w]=u #keep track of the node visited
}
}
}
return(prev)
}
path = savepath(prev,dest)
### Print path
path
dest=n #destination node
### create function which returns path
savepath = function(f,x){
path=x
while(f[x] != -1){
path=c(path,f[x])
x=f[x]
savepath(f,x)
}
path=c(path,1)
return(path)
}
S[6,7]=1
### Run Dijkstra's algorithm with our distance matrix
prev = dijkstra(n,v,cost,dest)
### Print path
path
### create function which returns path
savepath = function(f,x){
path=x
while(f[x] != -1){
path=c(path,f[x])
x=f[x]
savepath(f,x)
}
path=c(path,1)
return(path)
}
### Run Dijkstra's algorithm with our distance matrix
prev = dijkstra(n,v,cost,dest)
path = savepath(prev,dest)
### Print path
path
### Dijkstra's algorithm
dijkstra=function(n,v,cost,dest){
#create empty variables to store data
dest = numeric(n)
flag = numeric(n)
prev = numeric(n)
# for every node in the network
for(i in 1:n){
prev[i] = -1
dest[i] = cost[v,i] #= distance from start node v to every other node i in the network
}
#initialise counter which keeps track of number of steps through network
count=2
# until we have reached our destination node n
while(count <= n){
min=999
# loop over each node
for(w in 1:n){
#if the new path is less long than the existing smallest one and flag[w] is equal to zero (aka we've not already incuded that node in route)
if(dest[w] < min && !flag[w]){
# overwrite the minimum with the new shortest path and update counter
min=dest[w]
u=w
}
}
flag[u] = 1 #indicate that we go to this site
count = count+1
# loop over each node again keeping in mind where we have already been
for(w in 1:n){
#if the new route is shorter than the previous route
if((dest[u]+cost[u,w] < dest[w]) && !flag[w]){
dest[w]=dest[u]+cost[u,w] #update the distance to destination
prev[w]=u #keep track of the node visited
}
}
}
return(prev)
}
S=matrix(999,7,7)
S[1,2]=1
S[1,3]=2
S[2,5]=2
S[3,4]=1
S[4,5]=1
S[4,6]=3
S[5,6]=2
S[6,7]=1
### List of input parameters for function
n=length(S[,1]) #number of nodes
v=1 #source node
dest=n #destination node
cost=S #distance matrix
### Dijkstra's algorithm
dijkstra=function(n,v,cost,dest){
#create empty variables to store data
dest = numeric(n)
flag = numeric(n)
prev = numeric(n)
# for every node in the network
for(i in 1:n){
prev[i] = -1
dest[i] = cost[v,i] #= distance from start node v to every other node i in the network
}
#initialise counter which keeps track of number of steps through network
count=2
# until we have reached our destination node n
while(count <= n){
min=999
# loop over each node
for(w in 1:n){
#if the new path is less long than the existing smallest one and flag[w] is equal to zero (aka we've not already incuded that node in route)
if(dest[w] < min && !flag[w]){
# overwrite the minimum with the new shortest path and update counter
min=dest[w]
u=w
}
}
flag[u] = 1 #indicate that we go to this site
count = count+1
# loop over each node again keeping in mind where we have already been
for(w in 1:n){
#if the new route is shorter than the previous route
if((dest[u]+cost[u,w] < dest[w]) && !flag[w]){
dest[w]=dest[u]+cost[u,w] #update the distance to destination
prev[w]=u #keep track of the node visited
}
}
}
return(prev)
}
### create function which returns path
savepath = function(f,x){
path=x
while(f[x] != -1){
path=c(path,f[x])
x=f[x]
savepath(f,x)
}
path=c(path,1)
return(path)
}
### Run Dijkstra's algorithm with our distance matrix
prev = dijkstra(n,v,cost,dest)
path = savepath(prev,dest)
### Print path
path
S=matrix(999,7,7)
S[1,2]=1
S[1,3]=2
S[2,5]=2
S[3,4]=1
S[4,5]=1
S[4,6]=3
S[5,6]=2
S[6,7]=1
S
S=matrix(999,7,7)
S[1,2]=1
S[1,3]=2
S[2,5]=2
S[3,4]=1
S[4,5]=1
S[4,6]=3
S[5,6]=2
S[6,7]=1
S=matrix(999,7,7)
S[1,2]=1
S[1,3]=2
S[2,5]=2
S[3,4]=1
S[4,5]=1
S[4,6]=3
S[5,6]=2
S[6,7]=1
### List of input parameters for function
n=length(S[,1]) #number of nodes
v=1 #source node
dest=n #destination node
cost=S #distance matrix
n
numeric(n)
library(maxflow)
library(maxflow)
library(maxflow)
# Simulate 10 fake tracks with a mean distance of 500km
tracks <- rnorm(10, 500, 200)
# Create a fake list of sites where animals were seen at, with latitude, longitude and number of anumals seen there
dta <- data.frame(Site= LETTERS[1:4], Lat= 1:4, Lon= 5:8, Pop=100:103)
# create a distance matrix based on these data
dist <- point2DIST(dta)
# calculate the probability of going between these sites given the distance the animal can travel
Dist_P <- distPROB(tracks, dist, adjust=2, plot=TRUE)
# Calculate proportion going into a node
Pop_P <- popPROP(dta, 300)
# make birds/animals prefer sites which a larger proportion of the population has been seen and where the distance is better
network <- Dist_P * Pop_P
# Make the network directed
network <- directedNET(network, include_diagonal = TRUE)
#Add supersource and sink nodes
network <- addSUPERNODE(network)
network
library(maxflow)
# Simulate 10 fake tracks with a mean distance of 500km
tracks <- rnorm(10, 500, 200)
# Create a fake list of sites where animals were seen at, with latitude, longitude and number of anumals seen there
dta <- data.frame(Site= LETTERS[1:4], Lat= 1:4, Lon= 5:8, Pop=100:103)
# create a distance matrix based on these data
dist <- Point_2_Distance_Network(dta)
# calculate the probability of going between these sites given the distance the animal can travel
Dist_P <- Distance_Probability(tracks, dist, adjust=2, plot=TRUE)
# Calculate proportion going into a node
Pop_P <- Population_Proportion(dta, 300)
# make birds/animals prefer sites which a larger proportion of the population has been seen and where the distance is better
network <- Dist_P * Pop_P
# Make the network directed
network <- Make_Directed_Network(network, include_diagonal = TRUE)
#Add supersource and sink nodes
network <- Add_Source_Sink(network)
network
dta <- data.frame(Site= LETTERS[1:4], Lat= 1:4, Lon= 5:8, Pop=100:103)
dist <- point2DIST(dta)
addSUPERNODE(dist)
source= c("A","B")
sink = c("C","D")
dist = rbind(matrix(0,1,dim(dist)[2]),
dist,
matrix(0,1,dim(dist)[2]))
dist = cbind(matrix(0,dim(dist)[1],1),
dist,
matrix(0,dim(dist)[1],1))
which(colnames(dist) %in% start)
colnames(dist)
colnames(dist)[1] = rownames(dist)[1] = "source"
colnames(dist)[length(dist[1,])] = rownames(dist)[length(dist[1,])] = "sink"
dist[which(colnames(dist) %in% start)]
colnames(dist) %in% start
colnames(dist)
start
olnames(dist) %in% start
start
colnames(dist) %in% source
nrow(dist)
dist[1,colnames(dist) %in% source]=1
dist[rownames(dist) %in% sink, ncol(dist)]=1
dist
library(maxflow)
?rdist.earth
library(maxflow)
library(maxflow)
?approxfun
?density
?apply
library(maxflow)
?%in%
?SpatialPoints
?CRS
library(maxflow)
library(maxflow)
